# AuraUAS message serialization and deserialization

Given a json declaration of binary message structures, automatically
generate C++ and python code to implement managing, serializing, and
deserializtion (pack/unpack) of the messages.

Messaging is an often repeated task that is subject to mistakes,
typos, and inconsistencies between sending and receiving ends.  This
system helps streamline the process, make the code more consistant
(autogenerated) and reduces the chances that one end becomes out of
sync due to a typo or mistake.

This system is conceptually similar to mavlink, but without also
defining 80 pages of standard message types covering every possible
remote vehicle use-case in the universe.  The intention is for this
system to remain lean and focused.

* autogen.py: python script to auto generate C++ and python structures
  and code to manage the message types.
* example.json: an simple example message specification.
* messages.h: The autogenerated C++ header file including message
  structs and pack/unpack methods.
* messages.py: The autogenerated Python module that implements the identical
  byte stream serialization as the C++ code.
* example.cxx: An example C++ host program.
* example.py: An example python host program.

Because the system is designed to be lean, there is not a huge amount
of validation and run time checks inserted into the code.  It is the
responsibility of the developer/integrator to test the systems end to
end and make sure there aren't any python errors or data conversion
anomalies.

## Examples of things to watch out for:

* I want to represent a floating point value as a uint16_t.  Ex: I am
  sending alitude (floating point) as a uint16_t to save 2 bytes and I
  only need a value to the closest integer because I am only using
  this to draw an altimeter gauge.

  Wrong: { "type": "uint16_t", "name": "altitude_msl_ft" }
  -- Python will spew an error trying to pack a float type into a uint16_t
  
  Right: { "type": "float", "name": "altitude_msl_ft", "pack_type": "uint16_t", "pack_scale": 1 }
  -- This is a bit more verbose, but allows the correct type conversions to
  happen under the hood.

  If your entire communication pipeline will only involve C++, then
  the 'wrong' approach will work fine because of C++ implicite type
  casting rules ... however it is probably better to use the 'right'
  approach anyway.